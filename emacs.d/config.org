#+TITLE:  Emacs Configuration File
#+AUTHOR: Denis Evsyukov
#+EMAIL:  denis@evsyukov.org
#+PROPERTY:    results silent
#+PROPERTY:    header-args:emacs-lisp  :tangle yes
#+PROPERTY:    eval no-export

This is my configuration file, what I use in Emacs.

* Initialization

Load this file in Emacs. Then use =org-babel-tangle= command for generate =.emacs.el= file, this file should used as default configuration.

#+BEGIN_SRC emacs-lisp :tangle yes
  (eval-when-compile
    (require 'cl))
  (require 'package)
  (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t)
  (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t)
  (package-initialize nil)

  ;; Bootstrap `use-package'
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (use-package delight :ensure t)
  (use-package diminish :ensure t)
  (use-package use-package-ensure-system-package :ensure t)
  (setq use-package-always-ensure t)
  (setq package-enable-at-startup nil)
#+END_SRC

* Configuration
** Personal information
*** My name and email.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq user-full-name "Denis Evsyukov"
        user-mail-address "denis@evsyukov.org")
#+END_SRC

*** Load my secret file

#+BEGIN_SRC emacs-lisp :tangle yes
  ;;(load "~/.emacs.secrets" t)
#+END_SRC

** Better defaults

For a better user experience of GNU Emacs, here are the default values I use.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq
   ad-redefinition-action 'accept                   ; Silence warnings for redefinition
   cursor-in-non-selected-windows t                 ; Hide the cursor in inactive windows
   display-time-default-load-average nil            ; Don't display load average
   fill-column 80                                   ; Set width for automatic line breaks
   help-window-select t                             ; Focus new help windows when opened
   inhibit-startup-screen t                         ; Disable start-up screen
   initial-scratch-message ""                       ; Empty the initial *scratch* buffer
   load-prefer-newer t                              ; Prefers the newest version of a file
   scroll-conservatively most-positive-fixnum       ; Always scroll by one line
   select-enable-clipboard t                        ; Merge system's and Emacs' clipboard
   tab-width 4                                      ; Set width for tabs
   use-package-always-ensure t                      ; Avoid the :ensure keyword for each package
   vc-follow-symlinks nil                           ; Always follow the symlinks
   view-read-only t                                 ; Always open read-only buffers in view-mode
   make-backup-files nil)                           ; Disable backup files
  (cd "~/")                                         ; Move to the user directory
  (column-number-mode 1)                            ; Show the column number
  (display-time-mode 1)                             ; Enable time in the mode-line
  (fset 'yes-or-no-p 'y-or-n-p)                     ; Replace yes/no prompts with y/n
  (global-hl-line-mode)                             ; Hightlight current line
  (show-paren-mode 1)                               ; Show the parent
#+END_SRC

** Theme

I like the light on dark because I find it to be more restful.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package nord-theme
    :config
    (add-to-list 'custom-theme-load-path (expand-file-name "~/.emacs.d/themes/"))
    (load-theme 'nord t))

  (use-package smart-mode-line
    :defer 0.1
    :custom (sml/theme 'respectful)
    :config (sml/setup))
#+END_SRC

** No mouse

#+begin_src emacs-lisp :tangle yes
  (when window-system
    (menu-bar-mode t)                              ; Disable the menu bar
    (scroll-bar-mode -1)                            ; Disable the scroll bar
    (tool-bar-mode -1)                              ; Disable the tool bar
    (tooltip-mode -1))                              ; Disable the tooltips
#+end_src

** My theme customization

#+BEGIN_SRC emacs-lisp :tangle yes
  (set-frame-size (selected-frame) 140 50)

  (when window-system
    (require 'whitespace)
    (global-whitespace-mode +1)
    (set-face-attribute 'whitespace-space nil :background nil :foreground "gray80")
    (set-face-attribute 'whitespace-trailing nil :background "plum1" :foreground "gray80")
    (setq whitespace-style '(face tabs spaces tabs-mark space-mark trailing))
    (set-frame-size (selected-frame) 140 50)
    (set-default-font "PT Mono 14" nil t))

  (if (eq system-type 'windows-nt)
      (set-default-font "Fira Code 12" nil t))
#+END_SRC

** Hooks
*** Delete trailing whitespace

#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

*** Use subword mode for prog-mode files

#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'prog-mode-hook 'subword-mode)
#+END_SRC

*** Make executable file for scripts

#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'after-save-hook
            'executable-make-buffer-file-executable-if-script-p)
#+END_SRC

*** Create not exist directories

#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'before-save-hook
            (lambda ()
              (when buffer-file-name
                (let ((dir (file-name-directory buffer-file-name)))
                  (when (and (not (file-exists-p dir))
                             (y-or-n-p (format "Directory %s does not exist. Create it?" dir)))
                    (make-directory dir t))))))
#+END_SRC

*** Remove *Comletions* buffer when done

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Remove completion buffer when done
  (add-hook 'minibuffer-exit-hook
            '(lambda ()
               (let ((buffer "*Completions*"))
                 (and (get-buffer buffer)
                      (kill-buffer buffer)))))
#+END_SRC

*** Keep *scratch* buffer

#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'kill-buffer-query-functions
            (lambda() (not (equal (buffer-name) "*scratch*"))))
#+END_SRC
** Auto org-babel-tangle

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package async)

(defvar *config-file* (expand-file-name "config.org" user-emacs-directory)
  "The configuration file.")

(defvar *config-last-change* (nth 5 (file-attributes *config-file*))
  "Last modification time of the configuration file.")

(defvar *show-async-tangle-results* nil
  "Keeps *emacs* async buffers around for later inspection.")

(defun my/config-updated ()
  "Checks if the configuration file has been updated since the last time."
  (time-less-p *config-last-change*
               (nth 5 (file-attributes *config-file*))))

(defun my/config-tangle ()
  "Tangles the org file asynchronously."
  (when (my/config-updated)
    (setq *config-last-change*
          (nth 5 (file-attributes *config-file*)))
    (my/async-babel-tangle *config-file*)))

(defun my/async-babel-tangle (org-file)
  "Tangles the org file asynchronously."
  (let ((init-tangle-start-time (current-time))
        (file (buffer-file-name))
        (async-quiet-switch "-q"))
    (async-start
     `(lambda ()
        (require 'org)
        (org-babel-tangle-file ,org-file))
     (unless *show-async-tangle-results*
       `(lambda (result)
          (if result
              (message "SUCCESS: %s successfully tangled (%.2fs)."
                       ,org-file
                       (float-time (time-subtract (current-time)
                                                  ',init-tangle-start-time)))
            (message "ERROR: %s as tangle failed." ,org-file)))))))
#+END_SRC

** Functions and key-bindings
*** Jekyll

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq website-dir "~/Projects/juev.org/")

  (defun juev/sluggify (str)
    (replace-regexp-in-string
     "[^a-z0-9-]" ""
     (mapconcat 'identity
                (split-string
                 (downcase str) " ")
                "-")))

  (defun juev/new-post (title)
    (interactive "MTitle: ")
    (let ((slug (juev/sluggify title))
          (date (current-time)))
      (find-file (concat website-dir "source/_posts/"
                         (format-time-string "%Y-%m-%d") "-" slug
                         ".markdown"))
      (insert "---\n")
      (insert "layout: post\n")
      (insert "title: \"") (insert title) (insert "\"\n")
      (insert "date: ")
      (insert (format-time-string "%Y-%m-%d %H:%M")) (insert "\n")
      (insert "image: \n")
      (insert "tags:\n")
      (insert "  - \n")
      (insert "---\n\n")))
#+END_SRC

*** Open Notes

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun juev/open-my-notes ()
    (interactive)
    (find-file "~/Documents/notes.org"))

  (global-set-key (kbd "C-~") 'juev/open-my-notes)
#+END_SRC

*** Kill buffer without confirmation

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun juev/kill-current-buffer ()
    "Kill the current buffer without prompting."
    (interactive)
    (kill-buffer (current-buffer)))

  (global-set-key (kbd "C-x k") 'juev/kill-current-buffer)
#+END_SRC

*** Find-file as sudo

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun juev/find-file-as-sudo ()
    (interactive)
    (let ((file-name (buffer-file-name)))
      (when file-name
        (find-alternate-file (concat "/sudo::" file-name)))))
#+END_SRC

*** Generate password

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun juev/insert-random-string (len)
    "Insert a random alphanumeric string of length len."
    (interactive)
    (let ((mycharset "1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstyvwxyz"))
      (dotimes (i len)
        (insert (elt mycharset (random (length mycharset)))))))

  (defun juev/generate-password ()
    "Insert a good alphanumeric password of length 30."
    (interactive)
    (juev/insert-random-string 30))
#+END_SRC

*** Comment or uncomment region

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun juev/comment-or-uncomment-region-or-line ()
    "Comments or uncomments the region or the current line if there's no active region."
    (interactive)
    (let (beg end)
      (if (region-active-p)
          (setq beg (region-beginning) end (region-end))
        (setq beg (line-beginning-position) end (line-end-position)))
      (comment-or-uncomment-region beg end)))

  (global-set-key (kbd "M-;")
                  'juev/comment-or-uncomment-region-or-line)
#+END_SRC

*** Some keys

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; misc useful keybindings
  (global-set-key (kbd "s-<") #'beginning-of-buffer)
  (global-set-key (kbd "s->") #'end-of-buffer)
  (global-set-key (kbd "s-q") #'fill-paragraph)
  (global-set-key (kbd "s-x") #'execute-extended-command)
#+END_SRC

* Locale
** Use UTF-8

#+BEGIN_SRC emacs-lisp :tangle yes
  (when (display-graphic-p)
    (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
  (setq-default buffer-file-coding-system 'utf-8-unix)

  (setq locale-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
#+END_SRC

** Except selection coding on Windows

Because Windows used UTF-16

#+BEGIN_SRC emacs-lisp :tangle yes
  (unless (eq system-type 'windows-nt)
     (set-selection-coding-system 'utf-8))
#+END_SRC

* Packages
** Paredit

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package paredit
    :ensure t
    :diminish paredit-mode
    :init
    (progn
      (add-hook 'clojure-mode-hook #'enable-paredit-mode)
      (add-hook 'cider-repl-mode-hook #'enable-paredit-mode)
      (add-hook 'lisp-mode-hook #'enable-paredit-mode)
      (add-hook 'emacs-lisp-mode-hook #'enable-paredit-mode)
      (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode)
      (add-hook 'ielm-mode-hook #'enable-paredit-mode)
      (add-hook 'scheme-mode-hook #'enable-paredit-mode)
      (add-hook 'json-mode-hook #'enable-paredit-mode)))
#+END_SRC

** Rainbow delimeters

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package rainbow-delimiters
    :ensure t
    :config
    (progn
      (add-hook 'clojure-mode-hook #'rainbow-delimiters-mode)
      (add-hook 'prog-mode-hook #'rainbow-delimiters-mode)))
#+END_SRC

** Projectile

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package projectile
    :ensure t
    :diminish projectile-mode
    :config
    (projectile-global-mode))
#+END_SRC

** Magit

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package magit
    :ensure t
    :defer t
    :bind (("C-x v s" . magit-status)
           ("C-x v p" . magit-push))
    :init
    (setq magit-last-seen-setup-instructions "1.4.0"))
#+END_SRC

** Markdown Mode

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package markdown-mode
    :ensure t
    :mode (("\.markdown$" . markdown-mode)
           ("\.md$"       . markdown-mode))
    :config
    (progn
      (add-hook 'markdown-mode-hook #'visual-line-mode)))
#+END_SRC

** YAML Mode

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package yaml-mode
    :ensure t
    :mode (("\\.yml$" . yaml-mode))
    :config
    (add-hook 'yaml-mode-hook (lambda () (electric-indent-local-mode -1))))
#+END_SRC

** MultiMode

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package mmm-mode
    :ensure t
    :diminish mmm-mode
    :config
    (progn
      (setq mmm-global-mode 'maybe)
      (mmm-add-classes
       '((yaml-header-matters
          :submode yaml-mode
          :face mmm-code-submode-face
          :front "\\`---"
          :back "^---")))
      (mmm-add-mode-ext-class 'markdown-mode nil 'yaml-header-matters)))
#+END_SRC

** Slime

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package slime
    :ensure t
    :init
    (progn
      ;; (setq inferior-lisp-program "sbcl")
      (setq inferior-lisp-program "sbcl --noinform --no-linedit")
      ;; (setq inferior-lisp-program "ros -Q run")
      (slime-setup '(slime-asdf
                     slime-fancy
                     slime-indentation))
      (setq-default slime-net-coding-system 'utf-8-unix)))
#+END_SRC

** Which Key

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package which-key
    :ensure t
    :diminish which-key-mode
    :init
    (progn
      (which-key-setup-side-window-right)
      (which-key-mode)))
#+END_SRC

** Rust

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package rust-mode
    :ensure t)
#+END_SRC

** Guess Language

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package guess-language         ; Automatically detect language for Flyspell
    :ensure t
    :commands guess-language-mode
    :init (add-hook 'text-mode-hook #'guess-language-mode)
    :config
    (setq guess-language-languages '(en ru)
          guess-language-min-paragraph-length 35)
    :diminish guess-language-mode)
#+END_SRC

** Exec Path from Shell

#+BEGIN_SRC emacs-lisp

  (use-package exec-path-from-shell
    :ensure t
    :config
    (when (memq window-system '(mac ns))
      (exec-path-from-shell-initialize)))
#+END_SRC

** ivy

#+BEGIN_SRC emacs-lisp

(use-package counsel
   :after ivy
   :bind (("C-x C-f" . counsel-find-file)
          ("M-x" . counsel-M-x)
          ("M-y" . counsel-yank-pop)))

(use-package ivy
  :defer 0.1
  :diminish
  :bind (("C-c C-r" . ivy-resume)
         ("C-x b" . ivy-switch-buffer)
         ("C-x B" . ivy-switch-buffer-other-window))
  :custom
  (ivy-count-format "(%d/%d) ")
  (ivy-display-style 'fancy)
  (ivy-use-virtual-buffers t)
  :config (ivy-mode))

(use-package ivy-pass
  :after ivy
  :commands ivy-pass)

(use-package ivy-rich
  :after ivy
  :custom
  (ivy-virtual-abbreviate 'full
                          ivy-rich-switch-buffer-align-virtual-buffer t
                          ivy-rich-path-style 'abbrev)
  :config
  (ivy-set-display-transformer 'ivy-switch-buffer
                               'ivy-rich-switch-buffer-transformer))

(use-package swiper
  :after ivy
  :bind (("C-s" . swiper)
         ("C-r" . swiper)))

#+END_SRC

** helpful
#+BEGIN_SRC emacs-lisp

(use-package helpful
  :ensure t
  :bind
  ("C-h k" . helpful-key)
  ("C-h f" . helpful-callable)
  ("C-h v" . helpful-variable)
  ("C-h C" . helpful-command)
  ("C-h F" . helpful-function)
  (:map emacs-lisp-mode-map
        ("C-c C-d" . helpful-at-point)))
#+END_SRC

** ace-window
#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :ensure t
  :bind (("M-o" . ace-window)))
#+END_SRC

** expand-region
#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :ensure t
  :bind ("C-=" . er/expand-region))
#+END_SRC
** neotree
#+BEGIN_SRC emacs-lisp
(use-package neotree
  :ensure t
  :bind ("<f8>" . neotree-toggle))
   (setq projectile-switch-project-action 'neotree-projectile-action)
#+END_SRC
** Auto-Completion

=company= provides auto-completion at point and to Displays a small pop-in
containing the candidates.

#+BEGIN_QUOTE
Company is a text completion framework for Emacs. The name stands for "complete
anything". It uses pluggable back-ends and front-ends to retrieve and display
completion candidates.

[[http://company-mode.github.io/][Dmitry Gutov]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package company
    :ensure t
    :defer 2
    :diminish
    :custom
    (company-begin-commands '(self-insert-command))
    (company-idle-delay .1)
    (company-minimum-prefix-length 2)
    (company-show-numbers t)
    (company-tooltip-align-annotations 't)
    (global-company-mode t))
#+END_SRC

I use =company= with =company-box= that allows a company front-end with icons.

#+BEGIN_SRC emacs-lisp :tangle yes
 ;  (use-package company-box
 ;    :ensure t
 ;    :after company
 ;    :diminish
 ;    :hook (company-mode . company-box-mode))
#+END_SRC

** Buffers

Buffers can quickly become a mess. For some people, it's not a problem, but I
like being able to find my way easily.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ibuffer
    :defer 0.2
    :bind ("C-x C-b" . ibuffer))

  (use-package ibuffer-projectile
    :after ibuffer
    :preface
    (defun my/ibuffer-projectile ()
      (ibuffer-projectile-set-filter-groups)
      (unless (eq ibuffer-sorting-mode 'alphabetic)
        (ibuffer-do-sort-by-alphabetic)))
    :hook (ibuffer . my/ibuffer-projectile))
#+END_SRC

** Ivy

I used =helm= before, but I find =ivy= faster and lighter.

#+BEGIN_QUOTE
Ivy is a generic completion mechanism for Emacs. While it operates similarly to
other completion schemes such as icomplete-mode, Ivy aims to be more efficient,
smaller, simpler, and smoother to use yet highly customizable.

[[https://github.com/abo-abo/ivy][Oleh Krehel]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package counsel
    :after ivy
    :diminish
    :config (counsel-mode))

  (use-package ivy
    :defer 0.1
    :diminish
    :bind (("C-c C-r" . ivy-resume)
           ("C-x B" . ivy-switch-buffer-other-window))
    :custom
    (ivy-count-format "(%d/%d) ")
    (ivy-use-virtual-buffers t)
    :config (ivy-mode))

  (use-package ivy-pass
    :after ivy
    :commands ivy-pass)

  (use-package ivy-rich
    :after ivy
    :custom
    (ivy-virtual-abbreviate 'full
                            ivy-rich-switch-buffer-align-virtual-buffer t
                            ivy-rich-path-style 'abbrev)
    :config
    (ivy-set-display-transformer 'ivy-switch-buffer
                                 'ivy-rich-switch-buffer-transformer))

  (use-package swiper
    :after ivy
    :bind (("C-s" . swiper)
           ("C-r" . swiper)))
#+END_SRC
